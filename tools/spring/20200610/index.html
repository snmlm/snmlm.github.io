<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>spring ioc | snmlm</title><meta name="description" content="IOCIoC 全称为 Inversion of Control，翻译为 “控制反转”，这是一种思想，控制权转交给他人。  所谓Spring IoC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系在没有spring的时候，需要某个对象，一般都是已new的方式去创建，这个过程复杂而又繁琐，每个环节都要自己去把控，自己管理整个对象的生命周期，而且对象与对象之间都是耦合在一起的。"><meta name="keywords" content="tools,spring"><meta name="author" content="snmlm"><meta name="copyright" content="snmlm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://snmlm.github.io/tools/spring/20200610/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="spring ioc"><meta property="og:url" content="https://snmlm.github.io/tools/spring/20200610/"><meta property="og:site_name" content="snmlm"><meta property="og:description" content="IOCIoC 全称为 Inversion of Control，翻译为 “控制反转”，这是一种思想，控制权转交给他人。  所谓Spring IoC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系在没有spring的时候，需要某个对象，一般都是已new的方式去创建，这个过程复杂而又繁琐，每个环节都要自己去把控，自己管理整个对象的生命周期，而且对象与对象之间都是耦合在一起的。"><meta property="og:image" content="https://snmlm.github.io/img/head.gif"><meta property="article:published_time" content="2020-06-09T16:00:00.000Z"><meta property="article:modified_time" content="2021-05-06T14:28:02.311Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-05-06 22:28:02'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/head.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">67</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IOC"><span class="toc-number">1.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean"><span class="toc-number">2.</span> <span class="toc-text">Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%AB%E5%90%8D"><span class="toc-number">2.1.</span> <span class="toc-text">别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造函数实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.2.2.</span> <span class="toc-text">静态工厂方法实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.2.3.</span> <span class="toc-text">实例工厂方法实例化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.3.</span> <span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5"><span class="toc-number">2.4.</span> <span class="toc-text">注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87xml%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.1.</span> <span class="toc-text">通过xml配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">构造器注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setter-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">setter 方法注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">接口方式注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">自动注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">排除自动注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.1.6.</span> <span class="toc-text">p名称空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.1.7.</span> <span class="toc-text">c名称空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="toc-number">2.4.1.8.</span> <span class="toc-text">声明周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.4.1.8.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%80%E6%AF%81"><span class="toc-number">2.4.1.8.2.</span> <span class="toc-text">销毁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.1.8.3.</span> <span class="toc-text">抽象接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.4.2.</span> <span class="toc-text">通过注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.</span> <span class="toc-text">拓展接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">2.5.1.</span> <span class="toc-text">拓展接口调用时机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ClassPathXmlApplicationContext"><span class="toc-number">3.</span> <span class="toc-text">ClassPathXmlApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource%E4%BD%93%E7%B3%BB"><span class="toc-number">3.1.</span> <span class="toc-text">Resource体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory-%E4%BD%93%E7%B3%BB"><span class="toc-number">3.2.</span> <span class="toc-text">BeanFactory 体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Beandefinition-%E4%BD%93%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">Beandefinition 体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeandefinitionReader%E4%BD%93%E7%B3%BB"><span class="toc-number">3.4.</span> <span class="toc-text">BeandefinitionReader体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext%E4%BD%93%E7%B3%BB"><span class="toc-number">3.5.</span> <span class="toc-text">ApplicationContext体系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">IoC初始化</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/head.gif)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">snmlm</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">spring ioc</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-09T16:00:00.000Z" title="发表于 2020-06-10 00:00:00">2020-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-06T14:28:02.311Z" title="更新于 2021-05-06 22:28:02">2021-05-06</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>IoC 全称为 Inversion of Control，翻译为 “控制反转”，这是一种思想，控制权转交给他人。</p>
<blockquote>
<p>所谓Spring IoC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系<br>在没有spring的时候，需要某个对象，一般都是已new的方式去创建，这个过程复杂而又繁琐，每个环节都要自己去把控，自己管理整个对象的生命周期，而且对象与对象之间都是耦合在一起的。</p>
</blockquote>
<h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><p>Spring IoC容器管理一个或多个bean。这些bean是使用您提供给容器的配置元数据创建的（例如，以XML<bean/>定义的形式 ）。</p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">alias</span> <span class="title">name</span>=<span class="string">&quot;fromName&quot;</span> <span class="keyword">alias</span>=<span class="string">&quot;toName&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>Bean创建对象。</p>
<h3 id="构造函数实例化"><a href="#构造函数实例化" class="headerlink" title="构造函数实例化"></a>构造函数实例化</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attribute">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="静态工厂方法实例化"><a href="#静态工厂方法实例化" class="headerlink" title="静态工厂方法实例化"></a>静态工厂方法实例化</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">&quot;userDao&quot;</span></span><br><span class="line">    <span class="attribute">class</span>=<span class="string">&quot;com.ds.dao.UserDaoFactory&quot;</span></span><br><span class="line">    <span class="attribute">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实例工厂方法实例化"><a href="#实例工厂方法实例化" class="headerlink" title="实例工厂方法实例化"></a>实例工厂方法实例化</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">&quot;userDaoFactory&quot;</span> <span class="attribute">class</span>=<span class="string">&quot;com.ds.dao.UserDaoFactory&quot;</span> /&gt;</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">&quot;userDao&quot;</span></span><br><span class="line">    <span class="attribute">factory-bean</span>=<span class="string">&quot;userDaoFactory&quot;</span></span><br><span class="line">    <span class="attribute">factory-method</span>=<span class="string">&quot;createDaoInstance&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>懒加载，顾名思义，只有用的时候才会加载。<br>在spring中，配置懒加载优先级：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;                           &lt;bean /&gt;                   &lt;/beans&gt;  immediately</span><br><span class="line">&lt;beans&gt;                           &lt;bean <span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;true&quot;</span> /&gt;  &lt;/beans&gt;  <span class="built_in">lazy</span></span><br><span class="line">&lt;beans&gt;                           &lt;bean <span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;false&quot;</span>/&gt;  &lt;/beans&gt;  immediately</span><br><span class="line">&lt;beans <span class="keyword">default</span>-<span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;true&quot;</span>&gt;  &lt;bean/&gt;                    &lt;/beans&gt;  <span class="built_in">lazy</span>  </span><br><span class="line">&lt;beans <span class="keyword">default</span>-<span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;true&quot;</span>&gt;  &lt;bean <span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;true&quot;</span> /&gt;  &lt;/beans&gt;  <span class="built_in">lazy</span>  </span><br><span class="line">&lt;beans <span class="keyword">default</span>-<span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;true&quot;</span>&gt;  &lt;bean <span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;false&quot;</span> /&gt; &lt;/beans&gt;  immediately  </span><br><span class="line">&lt;beans <span class="keyword">default</span>-<span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;false&quot;</span>&gt; &lt;bean /&gt;                   &lt;/beans&gt;  immediately  </span><br><span class="line">&lt;beans <span class="keyword">default</span>-<span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;false&quot;</span>&gt; &lt;bean <span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;true&quot;</span> /&gt;  &lt;/beans&gt;  <span class="built_in">lazy</span>  </span><br><span class="line">&lt;beans <span class="keyword">default</span>-<span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;false&quot;</span>&gt; &lt;bean <span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">&quot;false&quot;</span> /&gt; &lt;/beans&gt;  immediately  </span><br></pre></td></tr></table></figure>

<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>spring就是把对象与对象的耦合变为，对象与spring的耦合，把对象与对象之间进行解耦。</p>
<p>原三层架构实例如下：<br>dao数据访问层：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserDao &#123;</span><br><span class="line">    void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="title">implements</span> <span class="title">UserDao</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">(<span class="keyword">String</span> name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;name：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service逻辑处理层：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserService &#123;</span><br><span class="line">    void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private UserDao dao = new UserDao();</span></span><br><span class="line">    <span class="keyword">private</span> UserDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">setUser</span><span class="params">(UserDao dao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dao = dao;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ui表示层或调用层：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> UserServiceImpl().setUser(<span class="keyword">new</span> UserDaoImpl()).getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对外开放dao的创建，不在service中new，暴露给调用者。这就很符合ioc的思想。</p>
<p>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式，在spring中实现控制反转的是ioc容器，其实现方法是依赖注入（Dependency Injection）<br>spring已经提供了几种对象依赖的方式：构造方法注入、stter方法注入、接口注入。</p>
<h3 id="通过xml配置"><a href="#通过xml配置" class="headerlink" title="通过xml配置"></a>通过xml配置</h3><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><p>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="built_in">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg <span class="built_in">name</span>=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;2222&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);<span class="comment">//默认根目录resources</span></span><br><span class="line">        <span class="keyword">new</span> UserServiceImpl().setUser((UserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>)).getUser();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器注入方式比较直观，对象构造完毕后就可以直接使用。</p>
<blockquote>
<p>循环依赖，如果只是用构造器注入，可能会创建无法解决的循环注入。<br>例如：A类通过构造函数注入需要B类的实例，而B类通过构造函数注入需要A类的实例。如果您将A类和B类的bean配置为相互注入，则Spring IoC容器会在运行时检测到此循环引用，并抛出 BeanCurrentlyInCreationException。</p>
<ul>
<li>解决方式<ul>
<li>通过修改源码，解决逻辑上的问题。</li>
<li>该用get，set注入。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="setter-方法注入"><a href="#setter-方法注入" class="headerlink" title="setter 方法注入"></a>setter 方法注入</h4><p>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="built_in">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;1111&quot;</span>&gt;&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前）。<br>property优先级比constructor-arg要低，会覆盖constructor-arg的赋值。</p>
<h4 id="接口方式注入"><a href="#接口方式注入" class="headerlink" title="接口方式注入"></a>接口方式注入</h4><p>接口方式注入需要被依赖的对象实现接口，并重写某些方法来实现功能。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doPost(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入了HttpServletRequest和HttpServletResponse。</p>
<h4 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h4><p>项目过大的话，配置property是一件非常繁琐的事，所以就有自动注入的配置了。</p>
<blockquote>
<p>要确保唯一bean命名。<br>否则转为明确的注入</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="排除自动注入"><a href="#排除自动注入" class="headerlink" title="排除自动注入"></a>排除自动注入</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans <span class="attribute">default-autowire-candidates</span>=<span class="string">&quot;true&quot;</span>/&gt; 集合排除自动注入</span><br><span class="line">&lt;bean <span class="attribute">autowire-candidate</span>=<span class="string">&quot;true&quot;</span> /&gt; 单独排除自动注入 内层覆盖外层配置</span><br></pre></td></tr></table></figure>
<h4 id="p名称空间"><a href="#p名称空间" class="headerlink" title="p名称空间"></a>p名称空间</h4><p>简化XML Schema文档定义中的property配置方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1111&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- p名称空间替换property --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">p:name</span>=<span class="string">&quot;2222&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="c名称空间"><a href="#c名称空间" class="headerlink" title="c名称空间"></a>c名称空间</h4><p>简化XML Schema文档定义中的constructor-arg配置方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- c名称空间替换constructor-arg --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ds.dao.UserDaoImpl&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">c:userDao1-ref</span>=<span class="string">&quot;userDao1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:userDao2-ref</span>=<span class="string">&quot;userDao2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul>
<li>用注释的方法 @PostConstruct，作用于方法，不能有参数。</li>
<li>实现InitializingBean接口，重写afterPropertiesSet()方法，官方不推荐，耦合了spring</li>
<li>xml配置bean时，选用init-method属性，自定义初始化方法，不能有参数。<ul>
<li>可以在beans配置default-init-method=”init”,内部bean类直接实现init方法，就可以定制初始化，不需要每个bean单独配置。</li>
</ul>
</li>
</ul>
<h5 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h5><ul>
<li>用注释的方法 @PreDestroy，作用于方法，不能有参数。</li>
<li>实现DisposableBean接口，重写destroy()方法。</li>
<li>xml配置bean时，选用destroy-method属性，自定义初始化方法，不能有参数。<ul>
<li>可以在beans配置default-destroy-method=”destroy”,内部bean类直接实现destroy方法，就可以定制初始化，不需要每个bean单独配置。</li>
</ul>
</li>
</ul>
<h5 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h5><p>Lifecycle是spring提供的抽象声明周期接口，当ApplicationContext启动和停止时，会自动调用Lifecycle实现的对应方法。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Lifecycle &#123;</span><br><span class="line">    void start();</span><br><span class="line">    void stop();</span><br><span class="line">    boolean isRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LifecycleProcessor继承了Lifecycle，多了两个方法。用于处理容器的refreshed和closed事件。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>LifecycleProcessor extends Lifecycle &#123;</span><br><span class="line">    void onRefresh();</span><br><span class="line">    void onClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SmartLifecycle实现Lifecycle和Phased，用于处理对象的依赖关系，哪些bean需先初始化，哪些需要在哪些bean完成某些动作后再进行初始化和销毁，getPhase表示为执行顺序，返回int。<br>启动时，最小的phase最先启动，停止时相反。因此，若对象实现了SmartLifecycle接口，它的getPhase()方法返回Integer.MIN_VALUE，那么该对象最先启动，最后停止。若是getPhase()方法返回Integer.MAX_VALUE，那么该方法最后启动最先停止。关于phase的值，常规的并未实现SmartLifecycle接口的Lifecycle对象，其值默认为0。因此，负phase值表示要在常规Lifecycle对象之前启动（在常规Lifecycyle对象之后停止），使用正值则恰恰相反。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Phased &#123;</span><br><span class="line">    int getPhase();</span><br><span class="line">&#125;</span><br><span class="line">public<span class="built_in"> interface </span>SmartLifecycle extends Lifecycle, Phased &#123;</span><br><span class="line">    boolean isAutoStartup();</span><br><span class="line">    void stop(Runnable callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SmartLifecycle中stop()方法有一个回调参数。所有的实现在关闭处理完成后会调用回调的run()方法，相当于开启异步关闭功能。<br>LifecycleProcessor接口在Spring中的默认实现是DefaultLifecycleProcessor类，该类会为每个回调等待超时，默认超时是30秒。<br>可以重写该类默认的参数，该类在容器内默认bean名称是lifecycleProcessor。比如修改超时时间：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifecycleProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeoutPerShutdownPhase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过注解"><a href="#通过注解" class="headerlink" title="通过注解"></a>通过注解</h3><ul>
<li>扫描<ul>
<li>@ComponentScan 自动扫描，一般配置在启动类上</li>
</ul>
</li>
<li>配置<ul>
<li>@Configuration 配置类 </li>
</ul>
</li>
<li>注册到容器<ul>
<li>@Bean 注册bean，可以作用于方法，对方法返回的对象注册到容器中</li>
<li>@Component 注册bean，只能作用于类<ul>
<li>@Controller 控制器，注入服务，封装了@Component，单纯用于分层</li>
<li>@Service 服务，注入dao，封装了@Component，单纯用于分层</li>
<li>@Repository dao，实现访问数据，封装了@Component，单纯用于分层</li>
</ul>
</li>
</ul>
</li>
<li>注入<ul>
<li>@Autowired 按byType自动注入，不用实现get，set方法<ul>
<li>允许null值 required=false</li>
<li>按名称匹配，需与@Qualifier(“名称”)连用</li>
</ul>
</li>
<li>JSR-250规范定义<ul>
<li>@Resource <ul>
<li>默认按byName自动注入</li>
<li>设置name 按byName自动注入</li>
<li>设置type 按byType自动注入</li>
<li>同时设置name，type，同时起作用，name+type唯一匹配</li>
</ul>
</li>
<li>@PostConstruct 自定义初始化</li>
<li>@PreDestroy 自定义销毁</li>
</ul>
</li>
<li>JSR-330规范定义<ul>
<li>@Inject 比@Autowired功能少，没有使用的必要</li>
</ul>
</li>
</ul>
</li>
<li>作用域<ul>
<li>@Scope <ul>
<li>singleton 单例</li>
<li>prototype 多例</li>
<li>session 会话</li>
<li>request 请求</li>
<li>application 应用</li>
<li>websocket </li>
<li>globalSession portlet Session声明周期</li>
</ul>
</li>
</ul>
</li>
<li>事务<ul>
<li>@Transactional</li>
</ul>
</li>
</ul>
<h2 id="拓展接口"><a href="#拓展接口" class="headerlink" title="拓展接口"></a>拓展接口</h2><ul>
<li>InitializingBean<ul>
<li>void afterPropertiesSet()<ul>
<li>bean初始化之后执行，可修改属性，自定义初始化</li>
</ul>
</li>
</ul>
</li>
<li>DisposableBean<ul>
<li>void destroy()<ul>
<li>bean销毁时执行</li>
</ul>
</li>
</ul>
</li>
<li>BeanNameAware<ul>
<li>void setBeanName(String var1)<ul>
<li>获取bean的id，当前类</li>
</ul>
</li>
</ul>
</li>
<li>ApplicationContextAware<ul>
<li>void setApplicationContext(ApplicationContext applicationContext)<ul>
<li>获取ApplicationContext实例</li>
</ul>
</li>
</ul>
</li>
<li>BeanFactoryAware<ul>
<li>void setBeanFactory(BeanFactory beanFactory)<ul>
<li>获取BeanFactory实例</li>
</ul>
</li>
</ul>
</li>
<li>FactoryBean<ul>
<li>自定义生成bean，不通过容器产生，由getObjeact返回</li>
<li>Object getObject()<ul>
<li>返回生成的bean对象</li>
</ul>
</li>
<li>Class&lt;?&gt; getObjectType<ul>
<li>返回bean的类型</li>
</ul>
</li>
<li>boolean isSingleton<ul>
<li>返回是否为单例</li>
</ul>
</li>
</ul>
</li>
<li>BeanPostProcessor<ul>
<li>后置处理器，可以获取beanName（非id），每个bean的产生都会执行</li>
<li>Object postProcessBeforeInitialization(Object bean, String beanName)<ul>
<li>对象实例化之后执行</li>
<li>对象初始化之前执行</li>
</ul>
</li>
<li>Object postProcessAfterInitialization(Object bean, String beanName)<ul>
<li>对象实例化之后执行</li>
<li>对象初始化之后执行</li>
</ul>
</li>
<li>在beafore和after之间会检查是否有实现InitializingBean的afterPropertiesSet方法以及是否xml中有配置init-method并执行初始化方法。init-method会覆盖afterPropertiesSet。</li>
</ul>
</li>
<li>BeanFactoryPostProcessor<ul>
<li>beanFactory后置处理器，只在factory生成时执行一次。</li>
<li>void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory)<ul>
<li>可以修改context中的beanFactory，这时候beanFactory已经standard initialization了</li>
<li>方法执行时机，所有的bean definitions已经加载，但没有bean实例化</li>
<li>可通过修改bean definitions来修改bean</li>
</ul>
</li>
</ul>
</li>
<li>InstantiationAwareBeanPostProcessor<ul>
<li>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<ul>
<li>对象实例化之前，如果返回非null，代表对象覆盖要生成对象，则下只执行postProcessAfterInitialization</li>
</ul>
</li>
<li>boolean postProcessAfterInstantiation(Object bean, String beanName)<ul>
<li>对象实例化之后属性复制前执行，如果返回false则下面的属性填充不执行，反之执行</li>
</ul>
</li>
<li>PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)</li>
<li>PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<ul>
<li>属性注入到目标对象之前执行，通过此方法修改对象属性，方法执行的前提是postProcessAfterInstantiation返回true</li>
</ul>
</li>
</ul>
</li>
<li>PropertyPlaceholderConfigurer<ul>
<li>将properties文件中的配置加载，并可替换xml中的$特殊字符</li>
</ul>
</li>
<li>PropertyOverrideConfigurer<ul>
<li>将properties文件中的配置加载，可替换bean属性的值</li>
</ul>
</li>
<li>ThreadFactory<ul>
<li>spring版本的线程工厂</li>
</ul>
</li>
<li>AbstractRoutingDataSource<ul>
<li>动态数据源</li>
</ul>
</li>
</ul>
<h3 id="拓展接口调用时机"><a href="#拓展接口调用时机" class="headerlink" title="拓展接口调用时机"></a>拓展接口调用时机</h3><ul>
<li>BeanFactory创建</li>
<li>BeanFactory创建之后，Bean实例化之前<ul>
<li>BeanFactoryPostProcessor.postProcessBeanFactory</li>
<li>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</li>
</ul>
</li>
<li>Bean实例化</li>
<li>Bean实例化之后<ul>
<li>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</li>
</ul>
</li>
<li>Bean属性赋值前<ul>
<li>InstantiationAwareBeanPostProcessor.postProcessProperties</li>
<li>InstantiationAwareBeanPostProcessor.postProcessPropertyValues</li>
</ul>
</li>
<li>Bean属性赋值</li>
<li>Bean属性赋值之后<ul>
<li>BeanNameAware.setBeanName</li>
<li>BeanFactoryAware.setBeanFactory</li>
<li>ApplicationContextAware.setApplicationContext</li>
</ul>
</li>
<li>Bean初始化之前<ul>
<li>BeanPostProcessor.postProcessBeforeInitialization</li>
</ul>
</li>
<li>Bean初始化<ul>
<li>注解PostConstruct</li>
<li>InitializingBean.afterPropertiesSet</li>
<li>xml中配置的init-method</li>
</ul>
</li>
<li>Bean初始化之后<ul>
<li>BeanPostProcessor.postProcessAfterInitialization</li>
</ul>
</li>
<li>容器初始化完成和使用</li>
<li>Bean销毁<ul>
<li>DisposableBean.setBeanName</li>
<li>xml中配置的destroy-method方法</li>
</ul>
</li>
</ul>
<h1 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h1><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/snmlm/resources/master/picture/13291365-fba6e7972333fed9.png"><br>该图为ClassPathXmlApplicationContext 的继承架构图，可以看到最上层的BeanFactory，创建bean的核心。ResourceLoader，资源加载器。ApplicationContext贯穿了整个spring框架。</p>
<h2 id="Resource体系"><a href="#Resource体系" class="headerlink" title="Resource体系"></a>Resource体系</h2><p>Resource，对资源的抽象，它的每一个实现类都代表了一种资源的访问策略，如ClasspathResource 、 URLResource ，FileSystemResource 等。有了资源，就应该有资源加载，Spring 利用 ResourceLoader 来进行统一资源加载。</p>
<h2 id="BeanFactory-体系"><a href="#BeanFactory-体系" class="headerlink" title="BeanFactory 体系"></a>BeanFactory 体系</h2><p>BeanFactory 是一个非常纯粹的 bean 容器，它是 IOC 必备的数据结构，其中 BeanDefinition 是她的基本结构，它内部维护着一个 BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。<br>BeanFacoty 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory，DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。</p>
<h2 id="Beandefinition-体系"><a href="#Beandefinition-体系" class="headerlink" title="Beandefinition 体系"></a>Beandefinition 体系</h2><p>BeanDefinition 用来描述 Spring 中的 Bean 对象。</p>
<h2 id="BeandefinitionReader体系"><a href="#BeandefinitionReader体系" class="headerlink" title="BeandefinitionReader体系"></a>BeandefinitionReader体系</h2><p>BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构：BeanDefinition。</p>
<h2 id="ApplicationContext体系"><a href="#ApplicationContext体系" class="headerlink" title="ApplicationContext体系"></a>ApplicationContext体系</h2><p>这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关，它继承 BeanFactory，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有：</p>
<ul>
<li>继承 MessageSource，提供国际化的标准访问策略。</li>
<li>继承 ApplicationEventPublisher ，提供强大的事件机制。</li>
<li>扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源。</li>
<li>对 Web 应用的支持。</li>
</ul>
<h1 id="IoC初始化"><a href="#IoC初始化" class="headerlink" title="IoC初始化"></a>IoC初始化</h1><p>Ioc的初始化，就要了解spring的启动顺序。<a href="#">Post not found: java/spring/20200710</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">snmlm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://snmlm.github.io/tools/spring/20200610/">https://snmlm.github.io/tools/spring/20200610/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://snmlm.github.io" target="_blank">snmlm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tools/">tools</a><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"><div class="social-share" data-image="/img/head.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/daily/20200622/"><img class="prev-cover" data-lazy-src="/img/head.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">秒杀方案</div></div></a></div><div class="next-post pull-right"><a href="/java/basics/20200609/"><img class="next-cover" data-lazy-src="/img/head.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java基础 全面理解servlet</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/tools/spring/20190411/" title="spring容器外调用容器内的对象"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-11</div><div class="title">spring容器外调用容器内的对象</div></div></a></div><div><a href="/tools/spring/20190421/" title="spring加载对象问题（坑）"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-21</div><div class="title">spring加载对象问题（坑）</div></div></a></div><div><a href="/tools/spring/20200710/" title="spring 启动"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-11</div><div class="title">spring 启动</div></div></a></div><div><a href="/tools/spring/20201202/" title="spring 自定义注解"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-02</div><div class="title">spring 自定义注解</div></div></a></div><div><a href="/tools/spring/20210511/" title="spirng bean的循环依赖以及解决方式"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-11</div><div class="title">spirng bean的循环依赖以及解决方式</div></div></a></div><div><a href="/tools/spring/20210508/" title="spirng AOP"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-08</div><div class="title">spirng AOP</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2021 By snmlm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/jsdelivr.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>