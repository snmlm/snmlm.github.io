<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java基础 线程池 | snmlm</title><meta name="description" content="线程池如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程的生命周期的维护是非常麻烦的事情，所以需要一种工具来智能的管理线程，大大减轻开发的难度和优化程序的健壮性，这就是线程池的由来。java本身已经提供了java.util.concurrent.Executor接口的实现用于创建线程池多线程技术主"><meta name="keywords" content="java"><meta name="author" content="snmlm"><meta name="copyright" content="snmlm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://snmlm.github.io/java/basics/20201203/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="java基础 线程池"><meta property="og:url" content="https://snmlm.github.io/java/basics/20201203/"><meta property="og:site_name" content="snmlm"><meta property="og:description" content="线程池如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程的生命周期的维护是非常麻烦的事情，所以需要一种工具来智能的管理线程，大大减轻开发的难度和优化程序的健壮性，这就是线程池的由来。java本身已经提供了java.util.concurrent.Executor接口的实现用于创建线程池多线程技术主"><meta property="og:image" content="https://snmlm.github.io/img/head.gif"><meta property="article:published_time" content="2020-12-02T16:00:00.000Z"><meta property="article:modified_time" content="2020-12-04T08:38:42.512Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-12-04 16:38:42'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/head.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">163</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">71</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.</span> <span class="toc-text">常见线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">2.1.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">2.2.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">2.3.</span> <span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newScheduledThreadPool"><span class="toc-number">2.4.</span> <span class="toc-text">newScheduledThreadPool</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">基本变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5"><span class="toc-number">3.3.</span> <span class="toc-text">其他字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Work%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.</span> <span class="toc-text">Work对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execute"><span class="toc-number">3.6.1.</span> <span class="toc-text">execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addWorker"><span class="toc-number">3.6.2.</span> <span class="toc-text">addWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runWorker"><span class="toc-number">3.6.3.</span> <span class="toc-text">runWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTask"><span class="toc-number">3.6.4.</span> <span class="toc-text">getTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processWorkerExit"><span class="toc-number">3.6.5.</span> <span class="toc-text">processWorkerExit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#submit"><span class="toc-number">3.6.6.</span> <span class="toc-text">submit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown"><span class="toc-number">3.6.7.</span> <span class="toc-text">shutdown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdownNow"><span class="toc-number">3.6.8.</span> <span class="toc-text">shutdownNow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryTerminate"><span class="toc-number">3.6.9.</span> <span class="toc-text">tryTerminate</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/head.gif)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">snmlm</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">java基础 线程池</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-02T16:00:00.000Z" title="发表于 2020-12-03 00:00:00">2020-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-04T08:38:42.512Z" title="更新于 2020-12-04 16:38:42">2020-12-04</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。<br>线程的生命周期的维护是非常麻烦的事情，所以需要一种工具来智能的管理线程，大大减轻开发的难度和优化程序的健壮性，这就是线程池的由来。<br>java本身已经提供了java.util.concurrent.Executor接口的实现用于创建线程池多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。</p>
<p>线程池包含以下四个基本部分组成:</p>
<ul>
<li>线程池管理器（ThreadPool）：用于创建并管理线程池，包括创建线程池，销管线程池，添加新任务。</li>
<li>工作线程（PoolWorker）：线程池中线程，在没有任务时出于等待状态，可以循环的执行任务。</li>
<li>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等。</li>
<li>任务队列（TaskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li>
</ul>
<p>空间换时间的操作，事先创建多个线程，放入线程池中，省去单个线程的创建于销毁的时间，专注于处理任务。</p>
<p>java中线程池的相关类的结构如下：<br><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/12/03/D7E8M9.png"></p>
<h1 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h1><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>        (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</li>
<li>如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。</li>
<li>此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>创建核心线程数1，最大线程数1的线程池，队列采用LinkedBlockingQueue（默认大小Integer.MAX_VALUE）；</li>
<li>LinkedBlockingQueue默认大小Integer.MAX_VALUE，大量请求堆积时，可能产生oom</li>
</ul>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建固定大小的线程池。创建核心线程数nThreads，最大线程数nThreads的线程池，队列采用阻塞队列LinkedBlockingQueue（默认大小Integer.MAX_VALUE）；</li>
<li>每提交一个任务就创建一个线程，直到线程数达到nThreads。</li>
<li>线程池的大小达到nThreads后，尽管keepAliveTime为0，因为核心线程数等于最大线程数，所以闲置线程不会被回收，线程池数量一直保持在nThreads；</li>
<li>如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>适用于处理并发相对比较稳定的任务。</li>
<li>LinkedBlockingQueue默认大小Integer.MAX_VALUE，大量请求堆积时，可能产生oom</li>
</ul>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个可缓存的线程池。核心线程数0，最大线程数Integer.MAX_VALUE的线程池，队列采用SynchronousQueue；不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间；</li>
<li>如果线程池的大小超过了处理任务所需要的线程，60秒过后回收闲置多余线程，当任务数重新增加时，线程池又可以添加新的线程来处理任务。此线程池不会对线程池大小做限制，线程池大小基本依赖于JVM能够创建的最大线程大小。</li>
<li>既可接受吞吐量高的并发，又能在并发小的时候减少创建线程，节省资源，可伸缩性好；</li>
<li>最大线程数Integer.MAX_VALUE，创建大量线程时，可能会oom</li>
</ul>
<h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService <span class="keyword">new</span><span class="constructor">ScheduledThreadPool(<span class="params">int</span> <span class="params">corePoolSize</span>)</span> &#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">ScheduledThreadPoolExecutor(<span class="params">corePoolSize</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="constructor">ScheduledThreadPoolExecutor(<span class="params">int</span> <span class="params">corePoolSize</span>)</span> &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="constructor">DelayedWorkQueue()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个大小无限的线程池。此线程池支持定时周期性执行任务。</li>
<li>创建核心线程数corePoolSize，最大线程数Integer.MAX_VALUE的线程池，</li>
<li>采用延迟队列DelayedWorkQueue；</li>
<li>主要执行可延迟性的，可定时周期控制的的任务；</li>
<li>最大线程数Integer.MAX_VALUE，创建大量线程时，可能会oom</li>
</ul>
<p>综上所述，建议用线程池类ThreadPoolExecutor自带构造方法自己根据适合的参数创建线程池。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myThreadPool-%d中的 ” %d ” 在String中表示整数的意思：</span></span><br><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> <span class="constructor">ThreadFactoryBuilder()</span></span><br><span class="line">        .set<span class="constructor">NameFormat(<span class="string">&quot;myThreadPool-%d&quot;</span>)</span>.build<span class="literal">()</span>;</span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> <span class="constructor">ThreadPoolExecutor(Runtime.<span class="params">getRuntime</span>()</span>.available<span class="constructor">Processors()</span>+<span class="number">1</span>,</span><br><span class="line">        <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>,</span><br><span class="line">        TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>),</span><br><span class="line">        namedThreadFactory,</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.<span class="constructor">AbortPolicy()</span>);</span><br></pre></td></tr></table></figure>

<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>java.util.concurrent包提供了现成的线程池的实现。</p>
<ul>
<li>ExecutorService<ul>
<li>真正的线程池接口。</li>
</ul>
</li>
<li>ScheduledExecutorService<ul>
<li>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</li>
</ul>
</li>
<li>ThreadPoolExecutor<ul>
<li>ExecutorService的默认实现。</li>
</ul>
</li>
<li>ScheduledThreadPoolExecutor<ul>
<li>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</li>
</ul>
</li>
</ul>
<p>基本实现：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService<span class="built_in"> service </span>= Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<p>常见线程池实现都是基于ThreadPoolExecutor实现的。提供4个构造器，逐层调用，最终实现在第4个构造器上。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler <span class="keyword">handler</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler <span class="keyword">handler</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctl 其实可以理解为单词 control 的简写, 翻译就是“控制”；</span></span><br><span class="line"><span class="comment">//修改此变量的操作，是原子性的；</span></span><br><span class="line"><span class="comment">//ctl 变量是Integer类型的，Integer.size在大多平台上是32位，</span></span><br><span class="line"><span class="comment">//该变量包含了两部分信息: 线程池的运行状态 (runState，前3位) ，</span></span><br><span class="line"><span class="comment">//和线程池内有效线程的数量 (workerCount，后29位)；</span></span><br><span class="line"><span class="comment">//在下面的属性方法中，ctl 简写c，runState简写rs，workerCount简写wc；</span></span><br><span class="line"><span class="comment">//初始化为RUNNING状态，线程个数为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//32-3=29，在大多平台上Integer.size = 32 位，之所以不直接用数字29，是为了规范性</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程池最大数，1左移29位，再减1，除前3位状态位，值全为1，</span></span><br><span class="line"><span class="comment">//即000 11111  11111111  11111111  11111111</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前3位 111</span></span><br><span class="line"><span class="comment">//接受新的任务，并且处理在阻塞队列中排队的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">-1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//前3位 000</span></span><br><span class="line"><span class="comment">//不再接受新任务，继续处理在阻塞队列排队中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//前3位 001</span></span><br><span class="line"><span class="comment">//不在接受新任务，不处理在阻塞队列排队中的任务，并且会中断正在运行中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//前3位 010</span></span><br><span class="line"><span class="comment">//整理中状态，所有任务执行完，阻塞队列执行完，工作线程数为0，过渡到此//状态的工作线程会调用方法terminated()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//前3位 011</span></span><br><span class="line"><span class="comment">//终态，上述讲的terminated()方法执行完成后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 低 29位与0计算，得到ctl前3位的值，即线程池的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line"> <span class="comment">// 将整数 c 低 29位与1计算，得到ctl后29位的值，即池中线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 计算ctl新值，即新的线程状态 与 线程个数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RUNNING -&gt; SHUTDOWN<ul>
<li>显式调用 shutdown() 方法，或者隐式调用了 finalize()，它里面调用了 shutdown() 方法；常见状态转换之一；</li>
</ul>
</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP<ul>
<li>显式调用 shutdownNow() 方法时候；常见状态转换之一；</li>
</ul>
</li>
<li>SHUTDOWN -&gt; TIDYING<ul>
<li>当线程池和任务队列为空的时候</li>
</ul>
</li>
<li>STOP -&gt; TIDYING<ul>
<li>当线程池为空的时候</li>
</ul>
</li>
<li>TIDYING -&gt; TERMINATED<ul>
<li>当 terminated() hook 方法执行完成时候</li>
</ul>
</li>
</ul>
<h2 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池主锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//存放worker的HashSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主锁等待条件队列，用于awaitTermination方法，在调用shutdown()或者//shutdownNow()方法后，其实线程池并没有真正关闭，这个方法可以设定一</span></span><br><span class="line"><span class="comment">//个超时时间，来检查在时间内线程池是否真正已经达到TERMINATED状态；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程池曾经创建过的最大线程数量。通过getLargestPoolSize()方法可以知道//线程池是否满过，也就是达到了maximumPoolSize</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//已完成任务数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//默认为false，核心线程池不会被回收，哪怕在闲置以后；</span></span><br><span class="line"><span class="comment">//如果设置为true，就在keepAliveTime到达超时后回收；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || <span class="keyword">handler</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">handler</span> = <span class="keyword">handler</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>int corePoolSize  (核心线程数大小)：当提交一个任务到线程池时，即便目前池中有空闲线程能够执行任务，线程池也会创建一个新线程来执行任务，直到池中线程数达到corePoolSize 数量；在这里要注意一点，线程池刚创建的时候，其中并没有创建任何线程数，而是等有任务提交后再去创建线程，除非调用了 prestartAllCoreThreads() 或者 prestartCoreThread() 方法 ，这样才会预先创建 corePoolSize 数量的线程。</li>
<li>int maximumPoolSize (线程池最大线程数)：线程池允许创建的最大线程数，如果线程池队列已满，并且已创建线程数小于最大线程数maximumPoolSize，则线程池会再创建新的线程执行任务，所以在通常情况下，maximumPoolSize &gt;= corePoolSize ， 值得注意的是，如果使用了无界队列，最大线程数此参数就没意义了。</li>
<li>long keepAliveTime (线程闲置存活时间)：此参数默认在当前线程数大于 corePoolSize 的情况下才会起作用， 当这些多余的线程，空闲时间达到 keepAliveTime 的时候就会终止，直至线程数目减到 corePoolSize 。不过如果调用了 allowCoreThreadTimeOut 方法，则当线程数目小于 corePoolSize 的时候也会起作用，keepAliveTime到达后闲置线程也会终止；</li>
<li>TimeUnit unit (keelAliveTime的时间单位)：keelAliveTime的时间单位。<ul>
<li>TimeUnit.NANOSECONDS 纳秒</li>
<li>TimeUnit.MICROSECONDS 微秒</li>
<li>TimeUnit.MILLISECONDS 毫秒</li>
<li>TimeUnit.SECONDS 秒</li>
<li>TimeUnit.MINUTES 分</li>
<li>TimeUnit.HOURS 时</li>
<li>TimeUnit.DAYS 天</li>
</ul>
</li>
<li>BlockingQueue<Runnable> workQueue (阻塞队列)：阻塞队列，用来存储等待执行的任务，这个参数也是非常重要的，在这里简单介绍一下几个阻塞队列。<ul>
<li>ArrayBlockingQueue：这是一个基于数组结构的有界阻塞队列，此队列按照FIFO的先进先出规则，进和出用的是同一个可重入锁。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按照FIFO排序元素，进和出分别采用两把锁，所以吞吐量通常要高于ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li>ThreadFactory threadFactory（创建线程池工厂）：用于设置创建线程的工厂，默认是使用Executors.defaultThreadFactory()，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给池里的线程设置有意义的名字，代码：new ThreadFactoryBuilder().setNameFormat(“XX-task-%d”).build();</li>
<li>RejectedExecutionHandler handler(饱和策略)；当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。从JDK 1.5开始， Java线程池框架提供了4种策略<ul>
<li>AbortPolicy：直接丢弃并且抛出 RejectedExecutionException 异常（默认）</li>
<li>CallerRunsPolicy：这个策略重试添加当前的任务，他会自动重复调用 execute() 方法，线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行；</li>
<li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于阻塞队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）；</li>
<li>DiscardPolicy：直接丢弃后面提交的任务并且不抛出异常。</li>
</ul>
</li>
</ul>
<h2 id="Work对象"><a href="#Work对象" class="headerlink" title="Work对象"></a>Work对象</h2><p>线程池中的线程，都被封装成了Worker对象，线程池维护的一组Worker对象，而Worker对象又继承AbstractQueuedSynchronizer类，使用AQS来实现独占锁的功能</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">Worker</span></span><br><span class="line">    <span class="symbol">extends</span> <span class="symbol">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="symbol">implements</span> <span class="symbol">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">6138294804551838833</span>L;</span><br><span class="line">    <span class="comment">/** 线程对象，真正在执行任务的活动线程 */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/**这里的 Runnable 是任务：在创建线程后需要执行的第一个任务，</span></span><br><span class="line"><span class="comment">    如果这个传入对象为空，在线程启动之后，不是执行空的任务，</span></span><br><span class="line"><span class="comment">    而是会到阻塞任务队列中自行取任务执行*/</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/**该线程完成的任务数 */</span></span><br><span class="line">    volatile long completedTasks;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(<span class="number">-1</span>); <span class="comment">//将state设置为-1，是为了防止在执行任务前对线程进行中断</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**调用外部主类的 runWorker 方法来运行线程 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean isHeldExclusively() &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean tryAcquire(<span class="built_in">int</span> unused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean tryRelease(<span class="built_in">int</span> unused) &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> lock()        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean tryLock()  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> unlock()      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isLocked() &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="built_in">int</span>erruptIfStarted() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="built_in">int</span>errupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command<span class="operator"> == </span>null)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">NullPointerException()</span>;</span><br><span class="line">    <span class="comment">//获取当前值</span></span><br><span class="line">    <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//如果当前线程数小于核心线程数，创建新线程执行该任务</span></span><br><span class="line">    <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">c</span>)</span> &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//第二个参数为true的时候，表示用corePoolSize</span></span><br><span class="line">        <span class="comment">//作为线程池工作线程数大小的上限，否则使用</span></span><br><span class="line">        <span class="comment">//maximumPoolSize作为线程池工作线程数上限；</span></span><br><span class="line">        <span class="keyword">if</span> (add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">true</span>)</span>)</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程池处于运行状态，并且插入阻塞队列排队成功</span></span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">Running(<span class="params">c</span>)</span><span class="operator"> &amp;&amp; </span>workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//再检查一次ctl变量</span></span><br><span class="line">        <span class="built_in">int</span> recheck = ctl.get<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">//如果线程池处于非运行状态，</span></span><br><span class="line">        <span class="comment">//如果现在正在关闭线程池，并且从阻塞队列成功移除当前线程；</span></span><br><span class="line">        <span class="comment">//就执行拒绝策略；</span></span><br><span class="line">        <span class="keyword">if</span> (! is<span class="constructor">Running(<span class="params">recheck</span>)</span><span class="operator"> &amp;&amp; </span>remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果线程池还是运行状态的，并且当前池中可用线程为0，</span></span><br><span class="line">        <span class="comment">//那么需要开启新的线程，并且addWorker方法第二个参数</span></span><br><span class="line">        <span class="comment">//为false，表示最大线程数可到maximumPoolSize；</span></span><br><span class="line">        <span class="comment">//防止任务在阻塞队列中后，但是可运行线程都关闭了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">recheck</span>)</span><span class="operator"> == </span><span class="number">0</span>)</span><br><span class="line">            add<span class="constructor">Worker(<span class="params">null</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果执行到这个if分支，有两种情况：</span></span><br><span class="line">    <span class="comment">//a、线程池非RUNNING状态；</span></span><br><span class="line">    <span class="comment">//b、或者线程池是RUNNING状态，但workerCount &gt;= corePoolSize</span></span><br><span class="line">    <span class="comment">//并且workQueue.offer返回false（说明阻塞队列已满），这时调用</span></span><br><span class="line">    <span class="comment">//addWorker方法，但第二个参数传入为false，将线程池的有限线程数量</span></span><br><span class="line">    <span class="comment">//的上限设置为maximumPoolSize；</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">false</span>)</span>)</span><br><span class="line">        <span class="comment">//添加线程任务失败，对当前线程执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><p>addWorker()方法，主要作用是在线程池中创建一个新的线程并执行添加进来的任务，并且firstTask是新增线程需要执行的第一个任务</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">	<span class="regexp">//</span>循环直到满足true或false，作为addWorker方法返回值</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="regexp">//</span>获取线程池ctl变量来得到运行状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"> </span><br><span class="line">        <span class="regexp">//</span> Check <span class="keyword">if</span> queue empty only <span class="keyword">if</span> necessary.</span><br><span class="line">        <span class="regexp">//</span><span class="number">1</span>、如果线程池不是SHUTDOWN或者后面的状态</span><br><span class="line">        <span class="regexp">//</span>（STOP, TIDYING, 或 TERMINATED）：</span><br><span class="line">        <span class="regexp">//</span>则不满足<span class="keyword">if</span>条件，那么逻辑向下执行，创建新线程接收执行任务；</span><br><span class="line">        <span class="regexp">//</span> false &amp;&amp; ? == false;</span><br><span class="line"> </span><br><span class="line">        <span class="regexp">//</span><span class="number">2</span>、如果线程池状态是SHUTDOWN状态：</span><br><span class="line">        <span class="regexp">//</span>（a）、并且下列语句条件只有全满足true时，</span><br><span class="line">        <span class="regexp">//</span> r s == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp;</span><br><span class="line">        <span class="regexp">//</span> ! workQueue.isEmpty()；</span><br><span class="line">        <span class="regexp">//</span>即线程池目前SHUTDOWN状态，新传入的任务对象为空，</span><br><span class="line">        <span class="regexp">//</span>并且阻塞任务队列不为空；</span><br><span class="line">        <span class="regexp">//</span>那么方法不返回，继续向下执行，因为目前队列中还有任务，</span><br><span class="line">        <span class="regexp">//</span>所以线程池继续运行，允许创建线程执行任务；</span><br><span class="line">        <span class="regexp">//</span> true &amp;&amp; ! (true &amp;&amp; true&amp;&amp; !false) == false</span><br><span class="line"> </span><br><span class="line">        <span class="regexp">//</span>（b）、SHUTDOWN状态，如果传入firstTask任务对象不为空，</span><br><span class="line">        <span class="regexp">//</span>不再新增任务线程，方法返回false；</span><br><span class="line">        <span class="regexp">//</span> true &amp;&amp; ! (true &amp;&amp; false&amp;&amp; ? ) == true</span><br><span class="line"> </span><br><span class="line">        <span class="regexp">//</span>（c）、SHUTDOWN状态，如果传入firstTask任务对象为空，</span><br><span class="line">        <span class="regexp">//</span>并且目前任务阻塞队列为空，队列都空了，所以无需新增任务线程；</span><br><span class="line">        <span class="regexp">//</span>方法返回false；        </span><br><span class="line">        <span class="regexp">//</span> true &amp;&amp; ! (true &amp;&amp; true&amp;&amp; ! ture ) == true</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="regexp">//</span>获取线程数；</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            <span class="regexp">//</span>根据core的boolean值，来决定取，</span><br><span class="line">            <span class="regexp">//</span>当前线程数wc是否超过CAPACITY和corePoolSize中最小值，</span><br><span class="line">            <span class="regexp">//</span>还是超过CAPACITY和maximumPoolSize中最小值；</span><br><span class="line">            <span class="regexp">//</span>如果超过了，那么返回不再添加新线程执行任务；</span><br><span class="line">            <span class="regexp">//</span>所以如果core传入false的话，那么运行线程池线程执行数</span><br><span class="line">            <span class="regexp">//</span>增加到maximumPoolSize；</span><br><span class="line">            <span class="regexp">//</span>core传入true的话，当前线程池线程数大于corePoolSize后，</span><br><span class="line">            <span class="regexp">//</span>不允许再增加线程数，addWorker方法返回false；</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">                <span class="regexp">//</span>尝试CAS增加workerCount线程数，</span><br><span class="line">                <span class="regexp">//</span>如果添加成功则跳出最外层<span class="keyword">for</span>循环，</span><br><span class="line">                <span class="regexp">//</span>并且将workerCount加<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="regexp">//</span>竞争添加失败，重新获取状态值，</span><br><span class="line">                <span class="regexp">//</span>跳出内<span class="keyword">for</span>循环，从外<span class="keyword">for</span>下一次循环继续开始；</span><br><span class="line">            c = ctl.get();  <span class="regexp">//</span> Re-read ctl</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="regexp">//</span> <span class="keyword">else</span> CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="regexp">//</span>执行到此处，说明工作线程数workerCount已经+<span class="number">1</span></span><br><span class="line">    <span class="regexp">//</span> worker是否已启动</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    <span class="regexp">//</span> worker是否已添加成功</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="regexp">//</span> 把firstTask创建成worker对象，</span><br><span class="line">        <span class="regexp">//</span>worker构造方法会从ThreadFactory创建一个线程</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != null) &#123;</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="regexp">//</span>获取整个线程池对象的锁，</span><br><span class="line">            <span class="regexp">//</span>在关闭线程池的时候，需要获取锁，</span><br><span class="line">            <span class="regexp">//</span>那么在锁期间，说明线程池不会被执行关闭</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="regexp">//</span> Recheck <span class="keyword">while</span> holding lock.</span><br><span class="line">                <span class="regexp">//</span> Back out on ThreadFactory failure or <span class="keyword">if</span></span><br><span class="line">                <span class="regexp">//</span> shut down before lock acquired.</span><br><span class="line">                <span class="regexp">//</span>获取运行状态</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="regexp">//</span>如果是SHUTDOWN之前的状态（只有RUNNING），</span><br><span class="line">                <span class="regexp">//</span>或者现在是SHUTDOWN并且传入的firstTask为空;</span><br><span class="line">                <span class="regexp">//</span>校验当前线程是否启动，因为workder中的线程不允许</span><br><span class="line">                <span class="regexp">//</span>是启动的，已启动抛出IllegalThreadStateException</span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="regexp">//</span> precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    <span class="regexp">//</span>添加到worker队列</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="regexp">//</span>添加worker队列成功后，启动这个线程 </span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="regexp">//</span>添加worker失败，addWorkerFailed方法善后工作</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="regexp">//</span>addWorkerFailed方法善后工作</span><br><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != null)</span><br><span class="line">        <span class="regexp">//</span>从worker队列中移除</span><br><span class="line">        workers.remove(w);</span><br><span class="line">        <span class="regexp">//</span>将workerCount减<span class="number">1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="regexp">//</span>尝试将线程池置为TERMINATED状态，当对线程池执行了</span><br><span class="line">        <span class="regexp">//</span>非正常逻辑的操作时，都需执行tryTerminate判断是否结束线程池</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="regexp">//</span>在finally块中释放锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">final void run<span class="constructor">Worker(Worker <span class="params">w</span>)</span> &#123;</span><br><span class="line">    Thread wt = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock<span class="literal">()</span>; <span class="comment">// allow interrupts</span></span><br><span class="line">    boolean completedAbruptly = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//循环调用getTask方法获取任务 </span></span><br><span class="line">        <span class="keyword">while</span> (task != null<span class="operator"> || </span>(task = get<span class="constructor">Task()</span>) != null) &#123;</span><br><span class="line">            w.lock<span class="literal">()</span>;</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">//如果线程池状态大于等于 STOP，线程就应中断 </span></span><br><span class="line">            <span class="keyword">if</span> ((run<span class="constructor">StateAtLeast(<span class="params">ctl</span>.<span class="params">get</span>()</span>, STOP) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">                 (<span class="constructor">Thread</span>.interrupted() <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">                  run<span class="constructor">StateAtLeast(<span class="params">ctl</span>.<span class="params">get</span>()</span>, <span class="constructor">STOP</span>))) <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">                !wt.is<span class="constructor">Interrupted()</span>)</span></span><br><span class="line"><span class="pattern-match">                wt.interrupt();</span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">                <span class="operator">/</span><span class="operator">/</span>目前什么都没做，留给子类实现的方法</span></span><br><span class="line"><span class="pattern-match">                before<span class="constructor">Execute(<span class="params">wt</span>, <span class="params">task</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">                <span class="constructor">Throwable</span> thrown = null;</span></span><br><span class="line"><span class="pattern-match">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span>开始执行任务</span></span><br><span class="line"><span class="pattern-match">                    task.run();</span></span><br><span class="line"><span class="pattern-match">                &#125; catch (<span class="constructor">RuntimeException</span> x) &#123;</span></span><br><span class="line"><span class="pattern-match">                    thrown = x; throw x;</span></span><br><span class="line"><span class="pattern-match">                &#125; catch (<span class="constructor">Error</span> x) &#123;</span></span><br><span class="line"><span class="pattern-match">                    thrown = x; throw x;</span></span><br><span class="line"><span class="pattern-match">                &#125; catch (<span class="constructor">Throwable</span> x) &#123;</span></span><br><span class="line"><span class="pattern-match">                    thrown = x; throw <span class="keyword">new</span> <span class="constructor">Error(<span class="params">x</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">                &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span>同样留给子类的方法 </span></span><br><span class="line"><span class="pattern-match">                    after<span class="constructor">Execute(<span class="params">task</span>, <span class="params">thrown</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">                &#125;</span></span><br><span class="line"><span class="pattern-match">            &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">                task = null;</span></span><br><span class="line"><span class="pattern-match">                <span class="operator">/</span><span class="operator">/</span>完成任务数+1</span></span><br><span class="line"><span class="pattern-match">                w.completed<span class="constructor">Tasks</span><span class="operator">++</span>;</span></span><br><span class="line"><span class="pattern-match">                w.unlock();</span></span><br><span class="line"><span class="pattern-match">            &#125;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        completed<span class="constructor">Abruptly</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">	    <span class="operator">/</span><span class="operator">/</span>当上面的<span class="keyword">while</span>循环中get<span class="constructor">Task</span>方法执行完毕以后，线程队列为空了，</span></span><br><span class="line"><span class="pattern-match">	    <span class="operator">/</span><span class="operator">/</span>统计整个线程池完成的任务个数,并从工作队列删除当前woker， </span></span><br><span class="line"><span class="pattern-match">	    <span class="operator">/</span><span class="operator">/</span>执行善后清理工作</span></span><br><span class="line"><span class="pattern-match">            process<span class="constructor">WorkerExit(<span class="params">w</span>, <span class="params">completedAbruptly</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h3><p>getTask方法返回null时，在之前runWorker方法中会跳出while循环，runWorker会执行finally块中的processWorkerExit方法：<br>在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize，并且workQueue已满时，则可以增加工作线程数到maximumPoolSize，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，那么当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，，如果之前设置过allowCoreThreadTimeOut为true，那么运行线程池数量降至corePoolSize以下。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = false; <span class="regexp">//</span> Did the last poll() time out?</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        <span class="regexp">//</span> 获取线程状态 </span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">        <span class="regexp">//</span> 如果线程池关闭或者正在关闭，那么执行workerCount减<span class="number">1</span></span><br><span class="line">        <span class="regexp">//</span>方法返回null</span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty()))     &#123;</span><br><span class="line">            <span class="regexp">//</span> cas方法，减少线程数workerCount</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line">        <span class="regexp">//</span> Are workers subject to culling?</span><br><span class="line">        <span class="regexp">//</span>如果之前allowCoreThreadTimeOut设置为true，</span><br><span class="line">        <span class="regexp">//</span>或者当前池中运行线程大于corePoolSize，</span><br><span class="line">        <span class="regexp">//</span>timed就为true；</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="regexp">//</span>timedOut如果为true，说明上次循环有超时发生，</span><br><span class="line">        <span class="regexp">//</span> timed &amp;&amp; timedOut 如果为true，表示需要超时超数控制，</span><br><span class="line">        <span class="regexp">//</span> 判断workerCount是否大于最大线程池数或者需超时空总控制，</span><br><span class="line">        <span class="regexp">//</span>是的话workerCount减<span class="number">1</span>，减<span class="number">1</span>成功后返回null，</span><br><span class="line">        <span class="regexp">//</span>不成功则<span class="keyword">continue</span>继续执行</span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="regexp">//</span>到 workQueue 中获取任务</span><br><span class="line">        <span class="regexp">//</span>如果上面的timed为true，则用poll超时方法从</span><br><span class="line">        <span class="regexp">//</span>阻塞队列中取线程对象；否则用take方法取线程对象</span><br><span class="line">        <span class="regexp">//</span>阻塞队列中，take方法是阻塞的，如果队列元素为<span class="number">0</span>则一直阻塞等待</span><br><span class="line">        <span class="regexp">//</span>而poll方法是非阻塞的，这里给定超时时间，获取不到直接返回；</span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="regexp">//</span>如果r不为空，说明已经从阻塞队列获取到线程对象，</span><br><span class="line">            <span class="regexp">//</span>否则没获取到线程对象，设置timedOut为true；</span><br><span class="line">            <span class="keyword">if</span> (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3><p>runWorker()方法执行完任务后，或者执行任务过程中出现异常中断执行的时，相对应的操作方法；<br>并且这里会移除线程池中的线程，因为异常情况添加到池中的线程没有执行的，这里移除以后重新添加线程执行;</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果正常执行完成，runWorker方法中completedAbruptly传的false</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        <span class="comment">//非正常执行完，线程池工作线程数减1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//完成任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//从线程池中移除一个工作线程，那么这个线程就销毁了；</span></span><br><span class="line">        <span class="comment">//这里只负责移除，在runWorker方法执行完之后，也就是Worker</span></span><br><span class="line">        <span class="comment">//中的run方法执行完，由JVM自动回收；</span></span><br><span class="line">        workers.<span class="built_in">remove</span>(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非正常逻辑的操作时，都需执行tryTerminate判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> c = ctl.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//如果是STOP之前的状态，即RUNNING或SHUTDOWN</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//如果是正常结束</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//allowCoreThreadTimeOut为true，</span></span><br><span class="line">            <span class="comment">//允许核心线程数收回，设置min为0，否则为核心线程数大小</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">//如果线程队列中还有线程，那么至少保留一个线程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                <span class="built_in">min</span> = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当前线程数比min（0或corePoolSize）大，无需新增线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= <span class="built_in">min</span>)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则应该是异常情况，重新添加一个线程执行任务;</span></span><br><span class="line">        addWorker(null, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">task</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(<span class="keyword">task</span>);</span><br><span class="line">    <span class="comment">//实际上执行的是execute方法，但是这里会有Future返回值，</span></span><br><span class="line">    <span class="comment">//后续可以通过Future调用get方法异步阻塞获取线程返回值；</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//检查关闭权限，如果设置了安全管理，则看当前调用 shutdown</span></span><br><span class="line">	<span class="comment">//方法的线程是否有关闭线程的权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">	<span class="comment">//检查当前状态如果是SHUTDOWN之后的状态则返回，</span></span><br><span class="line">	<span class="comment">//如果不是SHUTDOWN状态，设置当前状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">	<span class="comment">//这个方法有必要分析一下，往下看，从中文名称翻译来讲：</span></span><br><span class="line">	<span class="comment">//打断空闲的工作者</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//这里为什么要去获取w线程对象的锁，之前我们在看</span></span><br><span class="line">            <span class="comment">//addWorker()和runWorker()方法的时候，看到了对worker加</span></span><br><span class="line">            <span class="comment">//锁，说明正在入队的线程和正在执行的线程，不会中断他们；</span></span><br><span class="line">            <span class="comment">//这就是与下面shutdownNow()关闭线程池方法的区别所在；</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//满足上面的条件：线程非中断状态，并且获取锁</span></span><br><span class="line">                    <span class="comment">//则中断当前线程；</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放当前线程锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放线程池主锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否有关闭权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置线程池状态为STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里就比较简单粗暴，直接去打断线程，并不检查当前线程是否正在</span></span><br><span class="line">        <span class="comment">//运行或者已经添加到队列中；</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们看到shutdownNow()方法的返回类型是List&lt;Runnable&gt;，</span></span><br><span class="line"><span class="comment">//这个方法就是把目前阻塞队列中的元素都移除，并且封装到List集合里，</span></span><br><span class="line"><span class="comment">//返回给shutdownNow的调用者</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="keyword">remove</span>(r))</span><br><span class="line">                taskList.<span class="keyword">add</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h3><p>之前的关闭线程池方法和一些方法非正常执行后，都会调用tryTerminate</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">final void <span class="keyword">try</span><span class="constructor">Terminate()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">//RUNNING或TIDYING或（SHUTDOWN并且队列不为空）</span></span><br><span class="line">        <span class="comment">//这时候不会关闭线程池；</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="constructor">Running(<span class="params">c</span>)</span> <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">            run<span class="constructor">StateAtLeast(<span class="params">c</span>, TIDYING)</span> <span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">            (run<span class="constructor">StateOf(<span class="params">c</span>)</span> <span class="operator">==</span> <span class="constructor">SHUTDOWN</span> <span class="operator">&amp;&amp;</span> ! work<span class="constructor">Queue</span>.is<span class="constructor">Empty()</span>))</span></span><br><span class="line"><span class="pattern-match">            return;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span>如果池中线程数量不为0，则只中断一个空闲的线程</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">c</span>)</span> != 0) &#123; <span class="operator">/</span><span class="operator">/</span> <span class="constructor">Eligible</span> <span class="keyword">to</span> terminate</span></span><br><span class="line"><span class="pattern-match">            interrupt<span class="constructor">IdleWorkers(ONLY_ONE)</span>;</span></span><br><span class="line"><span class="pattern-match">            return;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match"> </span></span><br><span class="line"><span class="pattern-match">        final <span class="constructor">ReentrantLock</span> main<span class="constructor">Lock</span> = this.main<span class="constructor">Lock</span>;</span></span><br><span class="line"><span class="pattern-match">        main<span class="constructor">Lock</span>.lock();</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="operator">/</span><span class="operator">/</span>如果设置线程池状态为<span class="constructor">TIDYING</span>成功，</span></span><br><span class="line"><span class="pattern-match">            <span class="operator">/</span><span class="operator">/</span>则调用terminated方法（此方法内容为空，想做啥留给实现子类）</span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">if</span> (ctl.compare<span class="constructor">AndSet(<span class="params">c</span>, <span class="params">ctlOf</span>(TIDYING, 0)</span>)) &#123;</span></span><br><span class="line"><span class="pattern-match">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">                    terminated();</span></span><br><span class="line"><span class="pattern-match">                &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span>最后设置线程池状态为<span class="constructor">TERMINATED</span></span></span><br><span class="line"><span class="pattern-match">                    ctl.set(ctl<span class="constructor">Of(TERMINATED, 0)</span>);</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span>唤醒termination条件，在这个变量注释处提到过</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span>的await<span class="constructor">Termination</span>方法有用到</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span>termination.await<span class="constructor">Nanos(<span class="params">nanos</span>)</span></span></span><br><span class="line"><span class="pattern-match">                    termination.signal<span class="constructor">All()</span>;</span></span><br><span class="line"><span class="pattern-match">                &#125;</span></span><br><span class="line"><span class="pattern-match">                return;</span></span><br><span class="line"><span class="pattern-match">            &#125;</span></span><br><span class="line"><span class="pattern-match">        &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">            main<span class="constructor">Lock</span>.unlock();</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> <span class="keyword">else</span> retry on failed <span class="constructor">CAS</span></span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">snmlm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://snmlm.github.io/java/basics/20201203/">https://snmlm.github.io/java/basics/20201203/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://snmlm.github.io" target="_blank">snmlm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/img/head.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/system/20210412/"><img class="prev-cover" data-lazy-src="/img/head.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">编码</div></div></a></div><div class="next-post pull-right"><a href="/tools/spring/20201202/"><img class="next-cover" data-lazy-src="/img/head.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">spring 自定义注解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/java/basics/20181010/" title="java基础 for与foreach用法的区别"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-10</div><div class="title">java基础 for与foreach用法的区别</div></div></a></div><div><a href="/java/basics/20181011/" title="System.gc()与Object.finalize()的区别"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-11</div><div class="title">System.gc()与Object.finalize()的区别</div></div></a></div><div><a href="/java/basics/20181012/" title="java基础 Object"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-12</div><div class="title">java基础 Object</div></div></a></div><div><a href="/java/basics/20190416/" title="java调用js方法"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-16</div><div class="title">java调用js方法</div></div></a></div><div><a href="/java/basics/20190417/" title="ArrayList删除节点"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-17</div><div class="title">ArrayList删除节点</div></div></a></div><div><a href="/java/basics/20190418/" title="java基础 ==和equals"><img class="cover" data-lazy-src="/img/head.gif"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-04-18</div><div class="title">java基础 ==和equals</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2023 By snmlm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/jsdelivr.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>